// Authentication middleware for API routes
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { createHmac, timingSafeEqual } from 'node:crypto';

export const DEFAULT_ACTION_LINK_TTL_MS = 14 * 24 * 60 * 60 * 1000

function getActionLinkTtlMs(): number {
  const rawTtl = process.env.ACTION_LINK_TTL_MS;
  if (!rawTtl) {
    return DEFAULT_ACTION_LINK_TTL_MS;
  }

  const parsed = Number(rawTtl);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return DEFAULT_ACTION_LINK_TTL_MS;
  }

  return Math.floor(parsed);
}

export interface AuthenticatedRequest extends NextRequest {
  user?: {
    id: string;
    email: string;
  };
}

/**
 * Middleware to verify user authentication
 * Returns user info if authenticated, otherwise returns 401 error response
 */
export async function requireAuth(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _request: NextRequest
): Promise<{ user: { id: string; email: string } } | NextResponse> {
  try {
    const cookieStore = await cookies();
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return cookieStore.getAll();
          },
          setAll(cookiesToSet) {
            try {
              cookiesToSet.forEach(({ name, value, options }) =>
                cookieStore.set(name, value, options)
              );
            } catch {
              // Cookie setting can fail in middleware
            }
          },
        },
      }
    );

    const {
      data: { user },
      error,
    } = await supabase.auth.getUser();

    if (error || !user || !user.email) {
      return NextResponse.json(
        { error: 'Unauthorized', message: 'Authentication required' },
        { status: 401 }
      );
    }

    return { user: { id: user.id, email: user.email } };
  } catch (error) {
    console.error('Authentication error:', error);
    return NextResponse.json(
      { error: 'Authentication failed', message: 'Unable to verify credentials' },
      { status: 401 }
    );
  }
}

/**
 * Verify that the authenticated user can only access their own data
 * Prevents horizontal privilege escalation
 */
export function verifyEmailOwnership(
  authenticatedEmail: string,
  requestedEmail: string | null
): boolean {
  if (!requestedEmail) {
    return false;
  }
  return authenticatedEmail.toLowerCase() === requestedEmail.toLowerCase();
}

/**
 * Sanitize email input to prevent injection attacks
 */
export function sanitizeEmail(email: string | null): string | null {
  if (!email) return null;

  // Basic email validation regex
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

  const trimmed = email.trim().toLowerCase();

  if (!emailRegex.test(trimmed)) {
    return null;
  }

  // Prevent excessively long emails
  if (trimmed.length > 320) {
    return null;
  }

  return trimmed;
}

/**
 * Validate and sanitize day parameter
 */
export function sanitizeDay(day: string | number | null): number | null {
  if (day === null || day === undefined) return null;

  const dayNum = typeof day === 'string' ? parseInt(day, 10) : day;

  if (isNaN(dayNum) || !Number.isInteger(dayNum)) {
    return null;
  }

  // Reasonable bounds for day number
  if (dayNum < 1 || dayNum > 10000) {
    return null;
  }

  return dayNum;
}

/**
 * Build a deterministic token for email-based action links (email-open links from notifications)
 */
export function generateSignedActionToken(
  payload: { action: string; email: string; day?: string; extra?: string; iat?: string; expiresAt?: string }
): string {
  const secret = process.env.ACTION_LINK_SECRET;
  if (!secret) {
    return '';
  }

  const iat = payload.iat || String(Date.now());
  const iatMs = Number(iat);
  if (!Number.isFinite(iatMs) || iatMs <= 0) {
    return '';
  }

  const exp = payload.expiresAt || String(iatMs + getActionLinkTtlMs());

  const tokenPayload = [
    `action=${encodeURIComponent(payload.action)}`,
    `email=${encodeURIComponent(payload.email.toLowerCase())}`,
    `day=${encodeURIComponent(payload.day || '')}`,
    `extra=${encodeURIComponent(payload.extra || '')}`,
    `iat=${encodeURIComponent(iat)}`,
    `exp=${encodeURIComponent(exp)}`,
  ].join('&');

  const signature = createHmac('sha256', secret)
    .update(tokenPayload)
    .digest('hex');

  return `${tokenPayload}|${signature}`;
}

/**
 * Verify token generated by generateSignedActionToken
 */
export function verifySignedActionToken(
  token: string | null,
  expected: { action: string; email: string; day?: string; extra?: string; maxAgeMs?: number }
): boolean {
  if (!token) return false;
  const secret = process.env.ACTION_LINK_SECRET;
  if (!secret) return false;

  const parts = token.split('|');
  if (parts.length !== 2) return false;

  const tokenPayload = parts[0];
  const signature = parts[1];
  if (!tokenPayload || !signature) return false;

  const provided = new URLSearchParams(tokenPayload);
  const action = provided.get('action');
  const email = provided.get('email');
  const day = provided.get('day') || '';
  const extra = provided.get('extra') || '';
  const issuedAt = provided.get('iat') || '';
  const expiresAt = provided.get('exp') || '';

  if (!action || !email) return false;
  if (action !== expected.action) return false;
  if (email.toLowerCase() !== expected.email.toLowerCase()) return false;
  if (expected.day !== undefined && day !== expected.day) return false;
  if (expected.extra !== undefined && extra !== expected.extra) return false;

  if (expiresAt) {
    const exp = Number(expiresAt);
    if (Number.isNaN(exp) || exp <= 0) return false;
    if (Date.now() > exp) return false;
  } else if (expected.maxAgeMs) {
    const iat = Number(issuedAt);
    if (Number.isNaN(iat) || iat <= 0) return false;
    if (Date.now() - iat > expected.maxAgeMs) return false;
  } else if (!expected.maxAgeMs) {
    return false;
  }

  const expectedSig = createHmac('sha256', secret).update(tokenPayload).digest('hex');
  const sigBuf = Buffer.from(signature);
  const expectedBuf = Buffer.from(expectedSig);
  if (sigBuf.length !== expectedBuf.length) return false;

  return timingSafeEqual(sigBuf, expectedBuf);
}

/**
 * Check if authenticated user is admin based on env allowlist
 */
export function isAdminEmail(email: string): boolean {
  const adminEmails = process.env.ADMIN_EMAILS
    ?.split(',')
    .map((value) => value.trim().toLowerCase())
    .filter(Boolean);

  if (!adminEmails || adminEmails.length === 0) {
    return false;
  }

  return adminEmails.includes(email.toLowerCase());
}

/**
 * Optional helper for admin endpoints
 */
export function requireAdmin(email: string): boolean {
  return isAdminEmail(email);
}
